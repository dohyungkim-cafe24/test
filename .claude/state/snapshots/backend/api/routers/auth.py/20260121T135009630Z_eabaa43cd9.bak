"""Authentication router for OAuth flows and session management.

Implements F001: User Authentication
- AC-001: Kakao OAuth login
- AC-002: Google OAuth login
- AC-003: Session expiration and refresh
- AC-004: Logout
- AC-005: Protected route access
"""
from typing import Annotated, Optional
from urllib.parse import urlencode

from fastapi import APIRouter, Cookie, Depends, Header, HTTPException, Query, Response, status
from fastapi.responses import RedirectResponse

from api.config import Settings, get_settings
from api.schemas.auth import LogoutResponse, TokenError, TokenResponse, UserProfile
from api.services.oauth_service import OAuthService

router = APIRouter(prefix="/auth", tags=["auth"])


def get_oauth_service(settings: Annotated[Settings, Depends(get_settings)]) -> OAuthService:
    """Dependency to get OAuth service instance."""
    return OAuthService(settings)


async def get_current_user(
    authorization: Annotated[Optional[str], Header()] = None,
    settings: Settings = Depends(get_settings),
) -> dict:
    """Dependency to get current authenticated user.

    Args:
        authorization: Bearer token from Authorization header.
        settings: Application settings.

    Returns:
        User data dictionary.

    Raises:
        HTTPException: If token is missing or invalid.
    """
    if not authorization:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )

    if not authorization.startswith("Bearer "):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authorization header",
            headers={"WWW-Authenticate": "Bearer"},
        )

    token = authorization[7:]  # Remove "Bearer " prefix
    oauth_service = OAuthService(settings)

    try:
        payload = oauth_service.verify_access_token(token)
        # In production, fetch full user from database
        return {
            "id": payload["sub"],
            "email": payload["email"],
        }
    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token",
            headers={"WWW-Authenticate": "Bearer"},
        )


# === Kakao OAuth ===


@router.get("/kakao", response_class=RedirectResponse, status_code=status.HTTP_307_TEMPORARY_REDIRECT)
async def kakao_auth(
    oauth_service: Annotated[OAuthService, Depends(get_oauth_service)],
    redirect_uri: Optional[str] = Query(None, description="Post-auth redirect path"),
):
    """Initiate Kakao OAuth flow.

    Redirects to Kakao authorization page.
    """
    auth_url = oauth_service.get_kakao_auth_url(redirect_uri)
    return RedirectResponse(url=auth_url, status_code=status.HTTP_307_TEMPORARY_REDIRECT)


@router.get("/kakao/callback", response_class=RedirectResponse, status_code=status.HTTP_307_TEMPORARY_REDIRECT)
async def kakao_callback(
    response: Response,
    oauth_service: Annotated[OAuthService, Depends(get_oauth_service)],
    settings: Annotated[Settings, Depends(get_settings)],
    code: Optional[str] = Query(None),
    state: Optional[str] = Query(None),
    error: Optional[str] = Query(None),
    error_description: Optional[str] = Query(None),
):
    """Handle Kakao OAuth callback.

    Exchanges auth code for tokens and creates user session.
    """
    # Handle OAuth errors (user cancelled, etc.)
    if error:
        error_params = urlencode({"error": error, "error_description": error_description or ""})
        return RedirectResponse(
            url=f"{settings.frontend_url}/login?{error_params}",
            status_code=status.HTTP_307_TEMPORARY_REDIRECT,
        )

    # Missing state is a CSRF error
    if not state:
        error_params = urlencode({"error": "invalid_state", "error_description": "Missing state parameter"})
        return RedirectResponse(
            url=f"{settings.frontend_url}/login?{error_params}",
            status_code=status.HTTP_307_TEMPORARY_REDIRECT,
        )

    # Parse state to get redirect path
    _, redirect_path = oauth_service.parse_state(state)

    try:
        # Exchange code for tokens
        token_data = await oauth_service.exchange_kakao_code(code)
        access_token = token_data["access_token"]

        # Get user profile
        user_data = await oauth_service.get_kakao_user(access_token)

        # Extract user info from Kakao response
        provider_id = str(user_data["id"])
        kakao_account = user_data.get("kakao_account", {})
        email = kakao_account.get("email", f"{provider_id}@kakao.user")
        profile = kakao_account.get("profile", {})
        name = profile.get("nickname")
        avatar_url = profile.get("thumbnail_image_url")

        # Create our own tokens
        # In production, would create/update user in database first
        user_id = f"usr_{provider_id[:8]}"

        jwt_access_token = oauth_service.create_access_token(user_id, email)
        raw_refresh_token, token_hash, expires_at = oauth_service.create_refresh_token()

        # Set refresh token as HttpOnly cookie
        redirect_response = RedirectResponse(
            url=f"{settings.frontend_url}{redirect_path or '/dashboard'}?access_token={jwt_access_token}",
            status_code=status.HTTP_307_TEMPORARY_REDIRECT,
        )

        redirect_response.set_cookie(
            key="refresh_token",
            value=raw_refresh_token,
            httponly=True,
            secure=settings.is_production,
            samesite="lax",
            max_age=settings.refresh_token_expire_days * 24 * 60 * 60,
            path="/api/v1/auth",
        )

        return redirect_response

    except ValueError as e:
        error_params = urlencode({"error": "oauth_error", "error_description": str(e)})
        return RedirectResponse(
            url=f"{settings.frontend_url}/login?{error_params}",
            status_code=status.HTTP_307_TEMPORARY_REDIRECT,
        )


# === Google OAuth ===


@router.get("/google", response_class=RedirectResponse, status_code=status.HTTP_307_TEMPORARY_REDIRECT)
async def google_auth(
    oauth_service: Annotated[OAuthService, Depends(get_oauth_service)],
    redirect_uri: Optional[str] = Query(None, description="Post-auth redirect path"),
):
    """Initiate Google OAuth flow.

    Redirects to Google authorization page.
    """
    auth_url = oauth_service.get_google_auth_url(redirect_uri)
    return RedirectResponse(url=auth_url, status_code=status.HTTP_307_TEMPORARY_REDIRECT)


@router.get("/google/callback", response_class=RedirectResponse, status_code=status.HTTP_307_TEMPORARY_REDIRECT)
async def google_callback(
    response: Response,
    oauth_service: Annotated[OAuthService, Depends(get_oauth_service)],
    settings: Annotated[Settings, Depends(get_settings)],
    code: Optional[str] = Query(None),
    state: Optional[str] = Query(None),
    error: Optional[str] = Query(None),
    error_description: Optional[str] = Query(None),
):
    """Handle Google OAuth callback.

    Exchanges auth code for tokens and creates user session.
    """
    # Handle OAuth errors
    if error:
        error_params = urlencode({"error": error, "error_description": error_description or ""})
        return RedirectResponse(
            url=f"{settings.frontend_url}/login?{error_params}",
            status_code=status.HTTP_307_TEMPORARY_REDIRECT,
        )

    # Missing state is a CSRF error
    if not state:
        error_params = urlencode({"error": "invalid_state", "error_description": "Missing state parameter"})
        return RedirectResponse(
            url=f"{settings.frontend_url}/login?{error_params}",
            status_code=status.HTTP_307_TEMPORARY_REDIRECT,
        )

    # Parse state
    _, redirect_path = oauth_service.parse_state(state)

    try:
        # Exchange code for tokens
        token_data = await oauth_service.exchange_google_code(code)
        access_token = token_data["access_token"]

        # Get user profile
        user_data = await oauth_service.get_google_user(access_token)

        # Extract user info from Google response
        provider_id = user_data["sub"]
        email = user_data.get("email", f"{provider_id}@google.user")
        name = user_data.get("name")
        avatar_url = user_data.get("picture")

        # Create our own tokens
        user_id = f"usr_{provider_id[:8]}"

        jwt_access_token = oauth_service.create_access_token(user_id, email)
        raw_refresh_token, token_hash, expires_at = oauth_service.create_refresh_token()

        # Set refresh token as HttpOnly cookie
        redirect_response = RedirectResponse(
            url=f"{settings.frontend_url}{redirect_path or '/dashboard'}?access_token={jwt_access_token}",
            status_code=status.HTTP_307_TEMPORARY_REDIRECT,
        )

        redirect_response.set_cookie(
            key="refresh_token",
            value=raw_refresh_token,
            httponly=True,
            secure=settings.is_production,
            samesite="lax",
            max_age=settings.refresh_token_expire_days * 24 * 60 * 60,
            path="/api/v1/auth",
        )

        return redirect_response

    except ValueError as e:
        error_params = urlencode({"error": "oauth_error", "error_description": str(e)})
        return RedirectResponse(
            url=f"{settings.frontend_url}/login?{error_params}",
            status_code=status.HTTP_307_TEMPORARY_REDIRECT,
        )


# === Session Management ===


@router.post("/refresh", response_model=TokenResponse)
async def refresh_token(
    oauth_service: Annotated[OAuthService, Depends(get_oauth_service)],
    settings: Annotated[Settings, Depends(get_settings)],
    refresh_token: Annotated[Optional[str], Cookie()] = None,
):
    """Refresh access token using refresh token cookie.

    Returns new access token if refresh token is valid.
    """
    if not refresh_token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=TokenError(
                error="invalid_refresh_token",
                error_description="Missing refresh token",
            ).model_dump(),
        )

    try:
        # Hash the token and validate
        token_hash = oauth_service.hash_refresh_token(refresh_token)
        user_data = oauth_service.validate_refresh_token(token_hash)

        # Create new access token
        access_token = oauth_service.create_access_token(
            user_data["user_id"],
            user_data["email"],
        )

        return TokenResponse(
            access_token=access_token,
            token_type="Bearer",
            expires_in=settings.access_token_expire_minutes * 60,
        )

    except (ValueError, NotImplementedError) as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=TokenError(
                error="invalid_refresh_token",
                error_description=str(e) if str(e) else "Token expired or revoked",
            ).model_dump(),
        )


@router.post("/logout", response_model=LogoutResponse)
async def logout(
    response: Response,
    settings: Annotated[Settings, Depends(get_settings)],
    refresh_token: Annotated[Optional[str], Cookie()] = None,
):
    """Logout user and clear session.

    Revokes refresh token and clears cookies.
    """
    # Clear the refresh token cookie
    response.delete_cookie(
        key="refresh_token",
        path="/api/v1/auth",
        secure=settings.is_production,
        httponly=True,
        samesite="lax",
    )

    # In production, would also revoke the token in database
    # await revoke_refresh_token(refresh_token)

    return LogoutResponse(message="Logged out successfully")


# === Protected Routes ===


@router.get("/me")
async def get_me(
    current_user: Annotated[dict, Depends(get_current_user)],
):
    """Get current user profile.

    Requires valid access token.
    """
    # In production, would fetch full user from database
    return current_user
